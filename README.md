#  AM (async-methods)
>Efficiency wrapper for chaining any mix of asyncronous and syncronous processes using ES6 generators

```

am([3, 4, 5])
  	.filter(function* (elem, i) {
    	return yield Promise.resolve(4 * i > elem);
}).log();
  	
// 5
  	
```
## How it works

##### 1. Harnessing the flexibity of ES6 generators
**am** is a function that can wrap arrays, objects, generators, promises and other entities, always returning a generator.  The generator ('amGen') has extra set of methods which allow asynchronous operations to be intuitively chained.  

#####2. Mix sync and async operations
Most methods accept either a generator whish can host a sequence of async operations using **yield** or a normal function which will have same function but oeprate synchronously.

In this way syncronous operations of mapping, filtering etc can be combined with asynchronous mapping and filtering operations.

##### 3. Co is used to convert every generator chain to a promise
The **amGen** generators are interpreted with **co( )** so the same rules that oapply to **co(function*(){ })** 
apply to **am** methods

- yield arguments can be generators, promises **or**  functions with a single callback.
- errors from any stage within the generator are  returned to a **.catch()** at the end of the chain (unless **reset**).
- The end result of the operations of the chain is a promise accessed by .then().
- **co(amGen)** will always return a Promise.

#####4.  Replace async module with simpler ES6 patterns
 
## Installation
In package.json

```
	"async-methods":"ingenious/async-methods"
```

In console

```
	> npm install ingenious/async-methods
```
In code

```
	let am=require('async-methods');
```
##Wrapping

*Normal entities*

**am([3,4,5])** => generator that returns an array.

**am({a:3})** => generator that returns an object.

**am(iterator)**  => generator which returns an array of values generated by the iterator

**am(&lt;boolean | string | null&gt;)** => generator that returns entitity

*Entities with asynchronous returns*

**am(function(&lt;args&gt;, callback){ ... })** => generator that returns arguments of the callback and passes any err to a **.error(fn)**  or **.catch(fn)** at end of the chain.

**am(generator)**  => returns version of the generator with  chainable **amGen** methods attached

**am(&lt;Promise&gt;)**  => generator that returns the Promise resolved-value and passes any **err** to a **.error(fn)**  or **.catch(fn)** at end of the chain

**am.sfFn(function(<args>,successFn, errorFn)** => generator that returns arguments of the success callback and passes and argument of the error function to a **.error(fn)**  or **.catch(fn)** at end of the chain.

**am(amGen)** => identity

##Methods

> In all cases **fn** can be a **generator** or a normal function (for analagous synchronous operation)

*Returning a chainable generator*
###.map(fn)


###.filter(fn)


###.mapFilter(fn)

###.forEach(fn)

###.next(Fn)

###.timeout(ms)
###.wait(ms)

###.log()

###.error(fn)

*Returning a Promise (chainable as Promise)*
###.co(fn)
###.promise() 
-	*Alias for .co()*

###.then(fn)
###.catch(fn)

##Extensions 

>All extension methods return a chainable generator (*amGen*)

*async module replacement*

####am.waterfall([&lt;am-able>,&lt;am-able>,..])

*Promise method equivalents*

####am.all([&lt;am-able>,&lt;am-able>,..])
####am.resolve(value)
####am.reject(err)


