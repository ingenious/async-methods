#  AM (async-methods)
>Efficiency wrapper for chaining any mix of asyncronous and syncronous processes including  ES6 generators

```

	am([3, 4, 5]).filter(function* (elem, i) {
	
		// yielded async operation
    		return yield Promise.resolve(4 * i > elem);
	
	}).log();
  	
	// 5
  	
```
## How it works

#### 1. Harnessing the flexibity of ES6 generators
**am** is a function that can wrap arrays, objects, generators, promises and other entities, always returning an extended Promise.  The extended Promise has extra set of methods which allow asynchronous operations to be intuitively chained.  

#### 2. Mix sync and async operations
Most methods accept either a generator whish can host a sequence of async operations using **yield** or a normal function which will have same function but oeprate synchronously.

In this way syncronous operations of mapping, filtering etc can be combined with asynchronous mapping and filtering operations.

#### 3. am is 'co-compatible'
ES6 generators and yield statements are interpreted similarly

- yield arguments can be generators, promises, functions with a single callback - anything except functions with no callback.
- errors from any stage within the generator are returned to a **.catch()** or **.error()** at the end of the chain.

#### 4.  Replaces some common async module methods 
- **.parallel(), .waterfall()** can be replaced with simpler ES6 patterns
 
## Installation
In package.json

```
	"async-methods":"ingenious/async-methods"
```

In console

```
	> npm install ingenious/async-methods
```
In code

```
	let am=require('async-methods');
```
## Wrapping

*Normal entities*

**am([3,4,5])** => Extended Promise that returns an array.

**am({a:3})** => Extended Promise that returns an object.

**am(iterator)**  => Extended Promise which returns an array of values generated by the iterator

**am(&lt;boolean | string | null&gt;)** => Extended Promise that returns entitity

*Entities with asynchronous returns*

**am(function(&lt;args&gt;, callback){ ... },&lt;args&gt;)** => Extended Promise that returns arguments of the callback and passes any err to a **.error(fn)**  or **.catch(fn)** at end of the chain.

**am(generator)**  => returns Extended Promise (similar to 'co')

**am(&lt;Promise&gt;)**  => returns chainable Extended Promise

**am.sfFn(function(<args>,successFn, errorFn,&lt;args&gt;)** =>Extended Promise that returns arguments of the success callback and passes and argument of the error function to a **.error(fn)**  or **.catch(fn)** at end of the chain.

**am(<Extended Promise>)** => identity

## Methods

> In all cases **fn** can be a **generator** or a normal function (for analagous synchronous operation)

*Returning a chainable generator*
### .map(fn,tolerant)

### .filter(fn, tolerant)

### .mapFilter(fn, tolerant)

### .forEach(fn)

### .next(fn)

### .timeout(ms)
### .wait(ms)

### .log()

### .error(fn)

### .promise() 

### .then(fn)

### .catch(fn)

## Extensions 

>All extension methods return a chainable generator (*amGen*)

*async module replacement*

#### am.waterfall([&lt;am-able>,&lt;am-able>,..])
#### am.parallel([&lt;am-able>,&lt;am-able>,..])
#### am.forEach(array,fn) 
where fn is either a function that accepts a callback, or a generator



*Promise method equivalents*

#### am.resolve(value)
#### am.reject(err)
#### am.all([&lt;am-able>,&lt;am-able>,..])
#### am.race([&lt;am-able&gt;,&lt;am-able&gt;,..])


